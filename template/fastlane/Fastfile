# Customise this file, documentation can be found here:
# https://github.com/fastlane/fastlane/tree/master/fastlane/docs
# All available actions: https://docs.fastlane.tools/actions
# can also be listed using the `fastlane actions` command

# Change the syntax highlighting to Ruby
# All lines starting with a # are ignored when running `fastlane`

# If you want to automatically update fastlane if a new version is available:
# update_fastlane

# This is the minimum version number required.
# Update this, if you use features of a newer version
fastlane_version "2.19.1"

default_platform :ios

after_all do |lane|

end

def get_next_build_number(searchForTag)
  lastbuildtag = `git describe --match "#{searchForTag}*"`
  match = /\/[[:digit:]]+(\-|$)/.match(lastbuildtag)
  lastchar = match[0].length - 1
  buildNumberStr = match[0][1..lastchar]

  buildNumber = buildNumberStr.to_i
  buildNumber = buildNumber + 1
  return buildNumber.to_s
end

def certs_n_shit(app_identifier)
  match(
    type: "appstore",
    app_identifier: [
      app_identifier,
      <% if(HAS_EXTENSION_POSTFIX) { '#' } %>"#{app_identifier}.<%= EXTENSION_POSTFIX %>"
    ],
    clone_branch_directly: true
  ) # more information: https://codesigning.guide
end

error do |lane, exception|
  notification(
    title: 'Something went wrong!',
    message: exception.message
  )
end

before_all do
  versionNumber = JSON.parse(File.read("../package.json"))["version"]
  ENV['VERSION_NUMBER'] = ENV['FL_VERSION_NUMBER_VERSION_NUMBER'] = lane_context[SharedValues::VERSION_NUMBER] = versionNumber
  <% if(!ENABLE_TEAMS) { %>#<%}%>ENV['FASTLANE_TEAM_NAME'] = ENV['FASTLANE_ITC_TEAM_NAME'] = ENV['DEV_PORTAL_TEAM_NAME'] = ENV['PILOT_TEAM_NAME'] = '<%= TEAM_NAME %>'
  <% if(!ENABLE_ITC_PROVIDER) { %>#<%}%>ENV['PILOT_ITC_PROVIDER'] = '<%= PILOT_ITC_PROVIDER %>'

  <% if(!MATCH_GIT_URL) { '#' } %>ENV['MATCH_GIT_URL'] = '<%= MATCH_GIT_URL %>'
  <% if(!ENABLE_SUPPLY_JSON_KEY) { %>#<% } %>ENV['SUPPLY_JSON_KEY'] = ENV['<%= SUPPLY_JSON_KEY %>']
end

platform :android do
  before_all do
    # ENV["SLACK_URL"] = "https://hooks.slack.com/services/..."
    ENV['APPICON_PATH']='/android/app/src/main/res'
  end

  desc "Rebuild icons"
  lane :icons do
    android_appicon(
      appicon_image_file: 'appicon.png',
      appicon_devices: [:phone, :tablet],
      appicon_path: ".#{ENV['APPICON_PATH']}/mipmap"
    )

    android_appicon(
      appicon_image_file: 'appicon-notification-android.png',
      appicon_filename: 'ic_notification',
      appicon_devices: [:phone, :tablet],
      appicon_path: ".#{ENV['APPICON_PATH']}/mipmap"
    )
  end

  desc "Submit a new Alpha Build to Play Store"
  lane :alpha do
    buildNumber = get_next_build_number('fastlane-android')
    ENV['BUILD_NUMBER'] = buildNumber
    versionNumber = ENV['VERSION_NUMBER']

    lane_context[SharedValues::BUILD_NUMBER] = buildNumber
    <% if(ENABLE_BUGSNAG) { %>
    bundleForBugsnag("android")
    <% } %>
    <% if(!INCLUDE_SAMPLE_CONFIG_IMPLEMENTATION) { %> # <% } %>deployandroid('test')
    deployandroid('production', true)

    git_commit(
      message: "New Android alpha release #{versionNumber} (#{buildNumber})",
      path: ["fastlane/android/buildNumber"]
    )

    add_git_tag(
      grouping: "fastlane-android-builds",
      prefix: "#{versionNumber}/",
      build_number: buildNumber
    )

    notification(
      title: 'Done!',
      message: "Deployed new version #{versionNumber} (#{buildNumber}) to Google Play"
    )
  end

  desc "Build Android"
  lane :build do
    buildNumber = get_next_build_number('fastlane-android')

    gradle(task: 'clean', project_dir: "android/") # Clean the Gradle project
    gradle(task: 'assemble', build_type: 'Release', project_dir: 'android/', flavor: 'test',  properties: {
      'buildNumber' => buildNumber.to_i,
      'versionName' => ENV['VERSION_NUMBER']
    }) # Build the Release APK

    notification(
      title: 'Done!',
      message: "Android built and ready"
    )
  end
end

def deployandroid(flavor, is_production = false)
  `find $TMPDIR/react-native-packager-cache-* -name "mypattern" | xargs rm`;
  `rm -rf $TMPDIR`;

  app_identifier = is_production ? "<%= APP_IDENTIFIER %>" : "<%= APP_IDENTIFIER %>.#{flavor}"

  if !is_production
    add_badge(
      shield: "#{ENV['VERSION_NUMBER']}-#{lane_context[SharedValues::BUILD_NUMBER]}-orange",
      no_badge: is_production,
      alpha: true,
      dark: true,
      glob: "#{ENV['APPICON_PATH']}/**/*.{png,PNG}"
    )
  end

  gradle(task: 'clean', project_dir: "android/") # Clean the Gradle project
  gradle(task: 'assemble', build_type: 'Release', project_dir: 'android/', flavor: flavor, properties: {
    'buildNumber' => ENV['BUILD_NUMBER'],
    'versionName' => ENV['VERSION_NUMBER']
  }) # Build the Release APK

  supply(track: 'alpha',
    package_name: app_identifier,
    apk: "android/app/build/outputs/apk/app-#{flavor}-release.apk",
    skip_upload_metadata: true,
    skip_upload_images: true,
    skip_upload_screenshots: true
  ) # Upload the APK to the Play Store (alpha)
  <% if(ENABLE_BUGSNAG) { %>
  uploadBugsnag('android', app_identifier, ENV['VERSION_NUMBER'], lane_context[SharedValues::BUILD_NUMBER])
  <% } %>

  reset_git_repo(
    force: true,
    files: [
      ".#{ENV['APPICON_PATH']}",
    ]
  )
end

def resignAndDeploy(app_identifier)
  ENV["APP_IDENTIFIER"] = ENV['SIGH_APP_IDENTIFIER'] = app_identifier
  `rm -rf $TMPDIR`;

  act(
    archive_path: "<%= PROJECT_NAME %>.ipa",
    plist_values: {
      ":CFBundleIdentifier" => app_identifier,
    },
  )

  # this is an example if you have an extension
  <% if(HAS_EXTENSION_POSTFIX) { '#' } %>act(
  <% if(HAS_EXTENSION_POSTFIX) { '#' } %>  archive_path: "<%= PROJECT_NAME %>.ipa",
  <% if(HAS_EXTENSION_POSTFIX) { '#' } %>  plist_file: "PlugIns/<%= EXTENSION_POSTFIX %>.appex/Info.plist",
  <% if(HAS_EXTENSION_POSTFIX) { '#' } %>  plist_values: {
  <% if(HAS_EXTENSION_POSTFIX) { '#' } %>    ":CFBundleIdentifier" => "#{app_identifier}.<%= EXTENSION_POSTFIX %>",
  <% if(HAS_EXTENSION_POSTFIX) { '#' } %>  },
  <% if(HAS_EXTENSION_POSTFIX) { '#' } %>)

  sigh(app_identifier: "#{app_identifier}")
  <% if(HAS_EXTENSION_POSTFIX) { '#' } %>sigh(app_identifier: "#{app_identifier}.<%= EXTENSION_POSTFIX %>")

  resign(
    ipa: "<%= PROJECT_NAME %>.ipa", # can omit if using the `ipa` action
    use_app_entitlements: true,
    signing_identity: "<%= SIGNING_IDENTITY %>",
    bundle_id: app_identifier,
    provisioning_profile: {
      "#{app_identifier}" => "AppStore_#{app_identifier}.mobileprovision",
      <% if(HAS_EXTENSION_POSTFIX) { '#' } %>"#{app_identifier}.<%= EXTENSION_POSTFIX %>" => "AppStore_#{app_identifier}.<%= EXTENSION_POSTFIX %>.mobileprovision"
    }
  )

  begin
    pilot(
      skip_waiting_for_build_processing: true,
      app_identifier: ENV['APP_IDENTIFIER'],
    )

    rescue => ex
      UI.important('deliver failed, but continuing anyway!')
  end
  <% if(ENABLE_BUGSNAG) { %>
  uploadBugsnag('ios', app_identifier, ENV['VERSION_NUMBER'], lane_context[SharedValues::BUILD_NUMBER])
  <% } %>
end

def bundleForBugsnag(platform)
  Dir.chdir('..'){
    system("react-native bundle --platform #{platform} --bundle-output #{platform}.bundle --sourcemap-output #{platform}.bundle.map --entry-file index.js") || exit(1)
  }
end

def uploadBugsnag(platform, bundle, version, buildnumber)
  Dir.chdir('..'){
    system("curl https://upload.bugsnag.com/ -F apiKey=<%= BUGSNAG_API_KEY %> -F codeBundleId=#{bundle}-#{version}-#{buildnumber} -F minifiedUrl=main.jsbundle* -F sourceMap=@#{platform}.bundle.map -F minifiedFile=@#{platform}.bundle -F overwrite=true") || exit(1)

    upload_symbols_to_bugsnag
  }
end

platform :ios do
  before_all do
    # ENV["SLACK_URL"] = "https://hooks.slack.com/services/..."
    ENV["XCODE_PROJECT"] = ENV['FL_BUILD_NUMBER_PROJECT'] = ENV['FL_VERSION_NUMBER_PROJECT'] = "./ios/<%= PROJECT_NAME %>.xcodeproj"
  end

  desc "certs_n_shit"
  lane :certs do
    <% if(!INCLUDE_SAMPLE_CONFIG_IMPLEMENTATION) { %> # <% } %>certs_n_shit('<%= APP_IDENTIFIER %>.development')
    <% if(INCLUDE_SAMPLE_CONFIG_IMPLEMENTATION) { %> # <% } %>certs_n_shit('<%= APP_IDENTIFIER %>')
  end

  desc "deploy all ios builds"
  lane :deployios do
    # add all app identifiers you want to upload here
    <% if(!INCLUDE_SAMPLE_CONFIG_IMPLEMENTATION) { %> # <% } %>resignAndDeploy('<%= APP_IDENTIFIER %>.test')
    resignAndDeploy('<%= APP_IDENTIFIER %>')
  end

  desc "Regenerates appIcons"
  lane :icons do
    appicon(
      appicon_image_file: 'appicon-no-alpha.png',
      appicon_devices: [:ipad, :iphone],
      appicon_path: ENV['APPICON_PATH']
    )
  end

  desc "Submit a new Beta Build to Apple TestFlight"
  desc "This will also make sure the profile is up to date"
  lane :beta do
    buildNumber = get_next_build_number('fastlane-ios')
    ENV['BUILD_NUMBER'] = ENV['FL_BUILD_NUMBER_BUILD_NUMBER'] = lane_context[SharedValues::BUILD_NUMBER] = buildNumber

    increment_build_number()
    increment_version_number()

    update_info_plist(
      plist_path: "./<%= PROJECT_NAME %>/Info.plist",
      xcodeproj: ENV["XCODE_PROJECT"],
      block: lambda { |plist|
        plist.delete("NSAppTransportSecurity")
      }
    )

    certs

    gym(
      scheme: "<%= PROJECT_NAME %>",
      <% if(!ENABLE_WORKSPACES) { '#' } %>workspace: './ios/<%= PROJECT_NAME %>.xcworkspace'
    )
    <% if(ENABLE_BUGSNAG) { %>
    bundleForBugsnag("ios")
    <% } %>
    # resets temporary changes to
    reset_git_repo(
      force: true,
      files: [
        "./ios/<%= PROJECT_NAME %>/Info.plist",
        "#{ENV["XCODE_PROJECT"] }/project.pbxproj"
      ]
    )

    # bump buildnumber by adding git tag
    add_git_tag(
      grouping: "fastlane-ios-builds",
      prefix: "#{ENV['VERSION_NUMBER']}/",
      build_number: buildNumber
    )

    deployios

    message = "Deployed new version #{ENV['VERSION_NUMBER']} (#{buildNumber}) to iTunes Connect, expected review time is #{review_time} days :rocket:";

    puts message

    notification(
      title: 'Done!',
      message: message
    )
  end
end
